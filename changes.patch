diff --git a/README.md b/README.md
index 78f5887..3cb161a 100644
--- a/README.md
+++ b/README.md
@@ -1,2 +1,99 @@
-# bumpchannelopen
-Plugin to create cpfp transaction for opening lightning channels
+# BumpChannelOpen Plugin
+
+A Core Lightning plugin to create CPFP (Child Pays For Parent) transactions for opening lightning channels.
+
+## Prerequisites
+
+- Python 3.7+
+- Core Lightning node installed and configured
+- Bitcoin Core (for regtest environment)
+
+## Installation
+
+1. Clone the repository:
+
+```bash
+git clone https://github.com/yourusername/bumpchannelopen.git
+cd bumpchannelopen
+```
+
+2. Create and activate a virtual environment:
+```bash
+python -m venv .venv
+source .venv/bin/activate
+```
+
+3. Install dependencies:
+```bash
+# Install plugin dependencies
+pip install -r requirements.txt
+
+# Install test dependencies
+pip install -r requirements-dev.txt
+```
+
+## Running Tests
+
+The test suite uses Core Lightning's test framework and requires a regtest environment.
+
+```bash
+pytest test_bumpchannelopen.py
+```
+
+## Manual Testing in Regtest
+
+1. Navigate to Core Lightning's contrib directory:
+```bash
+cd ~/code/lightning/contrib
+```
+
+2. Start the regtest environment:
+```bash
+source startup_regtest.sh
+start_ln
+```
+
+3. Fund the nodes:
+```bash
+fund_nodes
+```
+
+4. Start the plugin:
+```bash
+l1-cli plugin start $PWD/bumpchannelopen.py
+```
+
+5. Get the funding transaction details:
+```bash
+l1-cli listfunds
+```
+
+6. Create a CPFP transaction:
+```bash
+l1-cli bumpchannelopen <txid> <vout> <fee_rate> "$(l1-cli newaddr | jq -r '.bech32')"
+```
+Note: `fee_rate` should be specified in sat/vB
+
+## Plugin Configuration
+
+The plugin accepts the following configuration options:
+
+- `bump_brpc_user`: Bitcoin RPC username
+- `bump_brpc_pass`: Bitcoin RPC password
+- `bump_brpc_port`: Bitcoin RPC port (default: 18443)
+
+## Contributing
+
+1. Fork the repository
+2. Create a new branch for your feature
+3. Make your changes
+4. Run the test suite to ensure everything works
+5. Submit a pull request
+
+## License
+
+[Add your license information here]
+
+## Support
+
+[Add support information or contact details]
diff --git a/bumpchannelopen.py b/bumpchannelopen.py
index 5d1767c..63911a7 100755
--- a/bumpchannelopen.py
+++ b/bumpchannelopen.py
@@ -8,13 +8,14 @@ import os
 plugin = Plugin()
 
 class CPFPError(Exception):
+    """Custom exception for CPFP-related errors"""
     pass
 
+# Plugin configuration options
 plugin.add_option('bump_brpc_user', None, 'bitcoin rpc user')
 plugin.add_option('bump_brpc_pass', None, 'bitcoin rpc password')
 plugin.add_option('bump_brpc_port', 18443, 'bitcoin rpc port')
 
-
 def connect_bitcoincli(rpc_user="__cookie__", rpc_password=None, host="127.0.0.1", port=18443):
     """
     Connects to a Bitcoin Core RPC server.
@@ -28,11 +29,6 @@ def connect_bitcoincli(rpc_user="__cookie__", rpc_password=None, host="127.0.0.1
     Returns:
         AuthServiceProxy: The RPC connection object.
     """
-    # try:
-    #     rpc_connection_test = rpc_connection.getblockchaininfo()
-
-    # Use the specified cookie file path for regtest
-
     if rpc_password is None:
         # Attempt to retrieve the cookie value from the regtest .cookie file
         try:
@@ -43,70 +39,23 @@ def connect_bitcoincli(rpc_user="__cookie__", rpc_password=None, host="127.0.0.1
             raise FileNotFoundError("Could not find the .cookie file. Ensure Bitcoin Core is running with cookie-based auth enabled.")
     
     rpc_url = f"http://{rpc_user}:{rpc_password}@{host}:{port}"
-
-    plugin.log("rpc_url: %s" % rpc_url)
+    plugin.log(f"Connecting to Bitcoin Core at: {rpc_url}")
     
     try:
-        rpc_connection = AuthServiceProxy(rpc_url)
-        return rpc_connection
+        return AuthServiceProxy(rpc_url)
     except Exception as e:
         raise ConnectionError(f"Error connecting to Bitcoin Core: {e}")
-    
 
-def calculate_confirmed_unreserved_amount(json_data):
+def calculate_confirmed_unreserved_amount(funds_data):
     """
-    Calculates the total amount in satoshis for outputs that are confirmed and not reserved.
-
-    :param json_data: A dictionary parsed from the JSON structure
-    :return: Total amount in satoshis
+    Calculates total amount in satoshis from confirmed and unreserved outputs.
     """
-    total_amount_sats = 0
-
-    # Ensure the "outputs" field exists in the JSON data
-    if "outputs" in json_data:
-        for output in json_data["outputs"]:
-            if (
-                output.get("status") == "confirmed" and  # Check for confirmed status
-                not output.get("reserved", False)        # Check if not reserved
-            ):
-                # Convert amount_msat (millisatoshis) to satoshis and add to total
-                total_amount_sats += output.get("amount_msat", 0) // 1000
-
-    return total_amount_sats
-
-
-# def estimate_tx_size(num_inputs, num_outputs, input_type="P2WPKH", output_type="P2WPKH"):
-#     """
-#     Estimate the size of the transaction based on input and output types.
-
-#     :param num_inputs: Number of inputs.
-#     :param num_outputs: Number of outputs.
-#     :param input_type: Type of input (e.g., "P2PKH", "P2WPKH", "P2SH-P2WPKH").
-#     :param output_type: Type of output (e.g., "P2PKH", "P2WPKH").
-#     :return: Estimated transaction size in bytes.
-#     """
-#     input_sizes = {"P2PKH": 148, "P2WPKH": 68, "P2SH-P2WPKH": 91}
-#     output_sizes = {"P2PKH": 34, "P2WPKH": 31}
-
-#     input_size = input_sizes.get(input_type, 148)  # Default to P2PKH
-#     output_size = output_sizes.get(output_type, 34)  # Default to P2PKH
-
-#     base_size = 10  # Base size for version, locktime, etc.
-#     tx_size = base_size + (num_inputs * input_size) + (num_outputs * output_size)
-#     return tx_size
-
-
-# def calculate_fee(fee_rate, tx_size):
-#     """
-#     Calculate the transaction fee based on size and fee rate.
-
-#     :param fee_rate: Fee rate in satoshis per byte.
-#     :param tx_size: Transaction size in bytes.
-#     :return: Fee in satoshis.
-#     """
-#     return fee_rate * tx_size
-
-#Â TODO
+    total_sats = 0
+    if "outputs" in funds_data:
+        for output in funds_data["outputs"]:
+            if output.get("status") == "confirmed" and not output.get("reserved", False):
+                total_sats += output.get("amount_msat", 0) // 1000
+    return total_sats
 
 def calculate_child_fee(parent_fee, parent_vsize, child_vsize, desired_total_feerate):
     """
@@ -127,12 +76,17 @@ def calculate_child_fee(parent_fee, parent_vsize, child_vsize, desired_total_fee
 @plugin.method("bumpchannelopen")
 def bumpchannelopen(plugin, txid, vout, fee_rate, address, **kwargs):
     """
-    Create a CPFP transaction for a specific parent output using lightning-utxopsbt.
+    Creates a CPFP transaction for a specific parent output.
+    
+    Args:
+        txid: Parent transaction ID
+        vout: Output index
+        fee_rate: Desired fee rate in sat/vB
+        address: Destination address for change
     """
-    if not txid:
-        raise CPFPError("txid is required.")
-    if vout is None:
-        raise CPFPError("vout is required.")
+    # Input validation
+    if not txid or vout is None:
+        raise CPFPError("Both txid and vout are required.")
 
     plugin.log(f"Input Parameters - txid: {txid}, vout: {vout}, fee_rate: {fee_rate}, address: {address}")
 
@@ -141,14 +95,9 @@ def bumpchannelopen(plugin, txid, vout, fee_rate, address, **kwargs):
     network = info.get('network')
     plugin.log(f"Network detected: {network}")
 
-    #Found a number that works but only if fee rate is 5, if it's high then the feerate drops, if it's low, then the feerate goes up
-    plugin.log(f"line 136 fee_rate before division: {fee_rate}")
-    # fee_rate = int(fee_rate/0.0004212)
-    # plugin.log(f"line 124 fee_rate after division: {fee_rate}")
-
     if not network:
-        plugin.log("Network information is missing")
         raise CPFPError("Network information is missing.")
+    plugin.log(f"Network detected: {network}")
 
     # Step 2: Get list of available UTXOs from the Lightning node
     funds = plugin.rpc.listfunds()
@@ -160,7 +109,6 @@ def bumpchannelopen(plugin, txid, vout, fee_rate, address, **kwargs):
     for idx, utxo in enumerate(utxos):
         plugin.log(f"{idx}: txid={utxo['txid']} vout={utxo['output']} amount={utxo['amount_msat']} msat")
 
-    plugin.log(f"line 154: txid variable contains this txid: {txid}")
 
     # Step 3: Calculate the total amount of confirmed and unreserved outputs
     total_sats = calculate_confirmed_unreserved_amount(funds)
@@ -168,7 +116,6 @@ def bumpchannelopen(plugin, txid, vout, fee_rate, address, **kwargs):
 
     # Step 4: Try to select an available, unreserved UTXO
     selected_utxo = None
-
     for utxo in utxos:
         if utxo["txid"] == txid and utxo["output"] == vout:
             if utxo.get("reserved", False):
@@ -177,15 +124,11 @@ def bumpchannelopen(plugin, txid, vout, fee_rate, address, **kwargs):
                 selected_utxo = utxo
                 break
 
-        plugin.log(f"line 171: txid variable contains this txid: {txid}")
-
     if not selected_utxo:
         raise CPFPError(f"UTXO {txid}:{vout} not found.")
     plugin.log(f"Selected UTXO: txid={selected_utxo['txid']}, vout={selected_utxo['output']}")
     plugin.log(f"Contents of selected_utxo: {selected_utxo}")
 
-    plugin.log(f"line 178: txid variable contains this txid: {txid}")
-
     # Step 5: Fetch UTXO details and convert amount
     amount_msat = selected_utxo["amount_msat"]
     if not amount_msat:
@@ -197,72 +140,15 @@ def bumpchannelopen(plugin, txid, vout, fee_rate, address, **kwargs):
     amount = amount_msat // 1000  # Convert msat to satoshis
     plugin.log(f"Fetched UTXO: txid={selected_utxo['txid']}, vout={selected_utxo['output']}, amount={amount} sats")
 
-    plugin.log(f"line 191: txid variable contains this txid: {txid}")
-
-
-    # # Step 6: Calculate fee and recipient amount
-    # # Estimate transaction size dynamically
-    # input_size = 180  # Approximate size for a typical input (adjust if needed)
-    # output_size = 34  # Typical size for an output
-    # tx_size = input_size + output_size  # Number of inputs
-    # plugin.log(f"Estimated transaction size: {tx_size} bytes")
-
-    # fee = int(fee_rate * tx_size)
-
-    # Step 6: Estimate transaction size and calculate fee
-    # num_inputs = 1
-    # num_outputs = 2  # One to destination and one for change (25,000 sats)
-
-    # tx_size = estimate_tx_size(num_inputs=num_inputs, num_outputs=num_outputs, input_type="P2WPKH", output_type="P2WPKH")
-    # plugin.log(f"Estimated transaction size: {tx_size} bytes")
-
-    # fee = calculate_fee(fee_rate, tx_size)
-    # plugin.log(f"Calculated fee: {fee} sats (Fee rate: {fee_rate} sat/vByte, Tx size: {tx_size} bytes)")
-
-    # if fee >= amount:
-    #     raise CPFPError("The fee exceeds the available amount in the UTXO.")
-
-    # remaining_amount = amount - fee
-    # plugin.log(f"Remaining amount after fee: {remaining_amount} sats, Amount: {amount}, Fee: {fee}")
-
-    # # Step 7: Subtract emergency channel amount (25,000 sats) from recipient_amount
-    # emergency_channel_amount = 25000  # Emergency channel amount in sats
-
-    # if amount <= emergency_channel_amount:
-    #     raise CPFPError("Not enough funds for fees and emergency reserve.")
-
-    # recipient_amount = amount - emergency_channel_amount - calculated_fee # Subtract emergency channel
-
-    # plugin.log(f"Reserve amount: {emergency_channel_amount} sats, Recipient amount: {recipient_amount} sats")
-
-
-    # Step 8: Use `lightning-withdraw` to create and broadcast the transaction
+    # Step 6: Use `txprepare` to create and broadcast the transaction
     utxo_selector = [f"{selected_utxo['txid']}:{selected_utxo['output']}"]
     plugin.log(f"Bumping selected output using UTXO {utxo_selector}")
 
-    # txid contains funding txid    
-    plugin.log(f"line 235: txid variable contains this txid: {txid}")
-
-    try:
-
-
-        # rpc_result = plugin.rpc.txprepare(
-        #     satoshi=recipient_amount,  # Or replace with the specific satoshi value if needed
-        #     feerate=fee_rate,  # Adjust based on your desired feerate
-        #     startweight=0,  # Default to 0 unless you have a specific weight
-        #     utxos=utxo_selector,  # Pass the selected UTXOs here
-        #     #reserve=72,  # Optional, default reserve period (adjust if needed)
-        #     # reservedok=False,  # Optional, allow using reserved UTXOs if set to True
-        #     # locktime=None,  # Optional, defaults to a recent block height
-        #     # min_witness_weight=0,  # Optional, adjust based on UTXO witness weight
-        #     excess_as_change=True,  # Optional, add change output for excess sats
-        #     opening_anchor_channel=False
-        # )
 
 
+    try:
         # First time we call txprepare with 0 receiving amount
         rpc_result = plugin.rpc.txprepare(
-            # outputs=[{address: recipient_amount}],
             outputs=[{address: 0}],
             utxos=utxo_selector,
             feerate=fee_rate
@@ -297,7 +183,6 @@ def bumpchannelopen(plugin, txid, vout, fee_rate, address, **kwargs):
         raise CPFPError(f"Error while withdrawing funds: {str(e)}")
 
 
-    # plugin.log(f"amount: {amount}, emergency_channel_amount: {emergency_channel_amount}, calculated_fee: {calculated_fee}")
 
     # Emergency channel amount in sats, cln will create an output of this amount
     # as long as we subtract it from the recipient amount
@@ -318,7 +203,6 @@ def bumpchannelopen(plugin, txid, vout, fee_rate, address, **kwargs):
         rpc_password=plugin.get_option('bump_brpc_pass'),
         port=plugin.get_option('bump_brpc_port')
     )
-    plugin.log(f"line 312: Contents of rpc_connection: {rpc_connection}")
 
     # Hardcoded values, user should pass in their host, port, rpcuser and rpcpassword
     # rpc_connection = AuthServiceProxy("http://%s:%s@127.0.0.1:18443"%("__cookie__", "12bacf16e6963c18ddfe8fe18ac275300d1ea40ed4738216d89bcf3a1b707ed3"))
@@ -332,20 +216,15 @@ def bumpchannelopen(plugin, txid, vout, fee_rate, address, **kwargs):
     total_outputs = sum(vout["value"] for vout in tx["vout"])
     # Calculate the fee
     parent_fee = total_inputs - total_outputs
-    plugin.log(f"Contents of parent_fee: {parent_fee}")
-
-    parsed_parent_hex = rpc_connection.getrawtransaction(txid)
-    plugin.log(f"Contents of parsed_parent_hex: {parsed_parent_hex}")
-
-    # Hardcoded values, user should pass in their host, port, rpcuser and rpcpassword
-    # rpc_connection = AuthServiceProxy("http://%s:%s@127.0.0.1:18443"%("__cookie__", "12bacf16e6963c18ddfe8fe18ac275300d1ea40ed4738216d89bcf3a1b707ed3"))
-    parent_tx_dict = rpc_connection.decoderawtransaction(parsed_parent_hex)
+    
+    # Get parent transaction size
+    parent_tx_hex = rpc_connection.getrawtransaction(txid)
+    parent_tx_dict = rpc_connection.decoderawtransaction(parent_tx_hex)
     parent_vsize = parent_tx_dict.get("vsize")
     plugin.log(f"Contents of parent_vsize: {parent_vsize}")
     parent_fee_rate = (parent_fee * 10**8) / parent_vsize  # sat/vB
     plugin.log(f"Contents of parent_fee_rate: {parent_fee_rate}")
 
-    # feb12_child_fee = calculate_child_fee(parent_fee, parent_vsize, child_size)
 
     # Second time we call txprepare
     try:
@@ -579,65 +458,11 @@ def bumpchannelopen(plugin, txid, vout, fee_rate, address, **kwargs):
     plugin.log(f"line 556: txid variable contains this txid: {txid}")
     plugin.log(f"line 557: second_child_txid variable contains this txid: {second_child_txid}")
 
-    # # First attempt using the bitcoin rpc_connection function:
+ 
 
-    # rpc_connection = connect_bitcoincli(
-    #     rpc_user=plugin.get_option('bump_brpc_user'),
-    #     rpc_password=plugin.get_option('bump_brpc_pass'),
-    #     port=plugin.get_option('bump_brpc_port')
-    # )
-    # plugin.log(f"line 384: Contents of rpc_connection: {rpc_connection}")
 
-    # parsed_parent_hex = rpc_connection.getrawtransaction(txid)
-    # plugin.log(f"line 387: Contents of parsed_parent_hex: {parsed_parent_hex}")
 
-    # # Hardcoded values, user should pass in their host, port, rpcuser and rpcpassword
-    # rpc_connection = AuthServiceProxy("http://%s:%s@127.0.0.1:18443"%("__cookie__", "12bacf16e6963c18ddfe8fe18ac275300d1ea40ed4738216d89bcf3a1b707ed3"))
-    # plugin.log(f"Contents of rpc_connection: {rpc_connection}")
-    # parsed_parent_hex = rpc_connection.getrawtransaction(txid)
-    # plugin.log(f"Contents of parsed_parent_hex: {parsed_parent_hex}")
-
-    # # Hardcoded values, user should pass in their host, port, rpcuser and rpcpassword
-    # # rpc_connection = AuthServiceProxy("http://%s:%s@127.0.0.1:18443"%("__cookie__", "12bacf16e6963c18ddfe8fe18ac275300d1ea40ed4738216d89bcf3a1b707ed3"))
-    # tx = rpc_connection.getrawtransaction(txid, True)
-    # # Calculate total inputs
-    # total_inputs = 0
-    # for vin in tx["vin"]:
-    #     input_tx = rpc_connection.getrawtransaction(vin["txid"], True)
-    #     total_inputs += input_tx["vout"][vin["vout"]]["value"]
-    # # Calculate total outputs
-    # total_outputs = sum(vout["value"] for vout in tx["vout"])
-    # # Calculate the fee
-    # parent_fee = total_inputs - total_outputs
-    # plugin.log(f"Contents of parent_fee: {parent_fee}")
-
-    # # Hardcoded values, user should pass in their host, port, rpcuser and rpcpassword
-    # # rpc_connection = AuthServiceProxy("http://%s:%s@127.0.0.1:18443"%("__cookie__", "12bacf16e6963c18ddfe8fe18ac275300d1ea40ed4738216d89bcf3a1b707ed3"))
-    # parent_tx_dict = rpc_connection.decoderawtransaction(parsed_parent_hex)
-    # parent_vsize = parent_tx_dict.get("vsize")
-    # plugin.log(f"Contents of parent_vsize: {parent_vsize}")
-    # parent_fee_rate = (parent_fee * 10**8) / parent_vsize  # sat/vB
-    # plugin.log(f"Contents of parent_fee_rate: {parent_fee_rate}")
 
-    # Hardcoded values, user should pass in their host, port, rpcuser and rpcpassword
-    # rpc_connection = AuthServiceProxy("http://%s:%s@127.0.0.1:18443"%("__cookie__", "12bacf16e6963c18ddfe8fe18ac275300d1ea40ed4738216d89bcf3a1b707ed3"))
-    # plugin.log(f"Contents of rpc_connection: {rpc_connection}")
-    # child_analyzed = rpc_connection.analyzepsbt(child_v0_psbt)
-    # child_fee = child_analyzed["fee"]
-    # child_vsize = child_analyzed["estimated_vsize"]
-    # child_feerate = child_analyzed["estimated_feerate"]
-    # plugin.log(f"Contents of child_fee: {child_fee}")
-    # plugin.log(f"Contents of child_vsize: {child_vsize}")
-    # plugin.log(f"Contents of child_feerate: {child_feerate}")
-
-    # total_vsizes = parent_vsize + child_vsize
-    # plugin.log(f"Contents of total_vsizes: {total_vsizes}")
-    # total_fees = (parent_fee + child_fee) * 10**8  # Convert fees to satoshis if in BTC
-    # plugin.log(f"Contents of total_fees: {total_fees}")
-    # total_feerate = total_fees / total_vsizes
-    # plugin.log(f"Contents of total_feerate: {total_feerate}")
-
-    # TODO Uncommet this next bit out til the next TODO
 
     # Update the dictionary with new key-value pairs & Convert non-serializable objects to serializable formats
     response.update({
@@ -646,9 +471,7 @@ def bumpchannelopen(plugin, txid, vout, fee_rate, address, **kwargs):
         "total_feerate": float(total_feerate) if total_feerate is not None else 0.0
     })
 
-    # plugin.log(f"Contents of response: {response}")
 
-    # TODO
 
     # # Prepare the final response
     # response = {
@@ -666,8 +489,9 @@ def bumpchannelopen(plugin, txid, vout, fee_rate, address, **kwargs):
 
     return response
 
-    # TODO
+    except Exception as e:
+        plugin.log(f"Error creating CPFP transaction: {str(e)}")
+        raise CPFPError(f"Failed to create CPFP transaction: {str(e)}")
 
-    # return "Great"
 
 plugin.run()
